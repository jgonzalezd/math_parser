exit
string[pos..pos+1]
/^\d+{2}/ =~ string[pos..pos+1]
/^\d+{2}/ =~ "1"
/^\d+{2}/ =~ "31"
/^\d+{2}/ =~ "3a"
/^\d+{2}/ =~ "34"
/^\d+{2}/ =~ "3"
/^\d+/ =~ "3"
/^\d+/ =~ "(3"
SIGNED_INTS =~ "(3"
SIGNED_INTS =~ string[pos+1]
!SIGNED_INTS =~ string[pos+1]
!!SIGNED_INTS =~ string[pos+1]
string[pos]
matched
string[pos+1]
exit
SIGNED_INTS =~ nil
string[pos]
string
matched
exit
string[pos+1]
exit
string[pos+1]
string[pos]
exit
string[pos+1]
string[pos]
matched
exit
matched
exit
matched
c
string
n
denom
num
exit
string[pos]
string
"(#{num}) / (#{denom})"
denom
num
exit
string
strin
n
string
denom
num
n
string
c
string
n
denom
den
string
num
n
exit
string[pos..pos+10]
string
matched
exit
exp
stack
n
stack
exp
n
fetch_token
exp
n
exp
token
n
exp
stack
n
stack
fetch_token
token
exp
n
string
token
n
matched
string[pos..pos+10]
pos
string
string[pos..pos+2]
c
string[pos..pos+2]
string[pos]
string
matched
c
denom
num
n
matched
stack
c
string
matched
n
stack
string
token
n
fetch_token
n
stack
n
prev
token
n
token
n
string
n
num
n
exit
string
c
string
num
n
matched
exit
input.objectify
expected_output
n
input.objectify
exit
remaining
first, remaining = args
args
c
exit
args
c
exit
op
args
el
c
args
c
exit
first
args
first
args
remaining
args
new_args
args
exit
args
exit
args
exit
args
n
node
n
new_args
n
args.all?{ |el| [Fixnum, Float, String, Object.const_get(op.capitalize)].include? el.class }
args
op
n
node
n
op
args
n
args
op
c
op
args
c
n
op
args
c
args
c
args
exit
args
c
args
c
args
exit
input.objectify
exit
c
args
c
new_args
n
args
op
c
new_args
n
el.class
op
args
c
n
args
c
args
c
args
exit
n
args_for_addition(args)
args
c
node
n
right
left
c
exit
input.objectify
exit
input.objectify
c
exit
expected_operations
exit
input.objectify
exit
args
op
c
op
args
c
args
c
args
exit
